# Comprobar si p es primo y si es safe prime (q=(p-1)//2 también primo)
p_str = "4381253625537323234121273482896462486903809883720268396400816392863142186635347893564298608797708804592302913394607277895736722852903202989743904493056796700538149476930485711116898383968502825816165560286075145973314227045231206954857274332073984221456395269319429821509132063400583193577872042027306693666630902938644466051169533699255274543484516827474728251175022268180295154501104890575919267514189052948703132643232167106367259660553238020236464755984245273239413636666467358008033251513792358104993184974997649531338963688262024316109363817460951505289325805892356970691688652619397689598530873541699657987193168156200762991236008605948515327093996499303887634815523900252744698958976377704874249573674880705173269798722284726581774909420888135292032680219570942768199519939513499328407198897703453991056189357041706323355099600748488776160609870621478646384814567116858862046810968540792030105064253114578403900211203"
p = int(p_str)

import secrets

def is_probable_prime(n, k=24):
    if n < 2:
        return False
    # División por primos pequeños
    small = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
    for sp in small:
        if n % sp == 0:
            return n == sp
    # n-1 = d * 2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    # Miller–Rabin
    for _ in range(k):
        a = secrets.randbelow(n - 3) + 2  # 2..n-2
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for __ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True

bits = p.bit_length()
is_p = is_probable_prime(p, k=32)         # más rondas = más confianza
q = (p - 1) // 2
is_q = is_probable_prime(q, k=32)

print("bits(p):", bits)
print("¿p primo?:", is_p)
print("¿q=(p-1)//2 primo?:", is_q)
print("→ ¿safe prime?:", is_p and is_q)
